<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>èˆ¹èˆ¶æŸ´æ²¹æœºå†·å´æ°´è‡ªåŠ¨æ§åˆ¶ä»¿çœŸç³»ç»Ÿ V5.0</title>
    <style>
        body { margin: 0; background: #1e272e; font-family: "Segoe UI", "Microsoft YaHei", sans-serif; overflow: hidden; user-select: none; }
        canvas { display: block; background: #ffffff; }
        @media screen and (orientation: portrait) and (max-width: 1024px) {
    #main-wrapper {
        width: 100vh; height: 100vw;
        position: absolute; top: 0; left: 100vw;
        transform: rotate(90deg); transform-origin: top left;
    }
}
        #ctrl-panel {
            position: absolute; left: 1230px; top: 35px; width: 230px;
            background: rgba(255, 255, 255, 0.95); border-left: 5px solid #2980b9;
            border-radius: 4px; padding: 12px; z-index: 1000; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            cursor: move;
        }
        .panel-title { font-weight: bold; text-align: center; border-bottom: 1px solid #eee; margin-bottom: 10px; padding-bottom: 5px; color: #2c3e50; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px; }
        button { padding: 8px 4px; cursor: pointer; border: 1px solid #bdc3c7; border-radius: 4px; background: #fdfdfe; font-size: 11px; font-weight: bold; transition: 0.2s; }
        button:hover { background: #ecf0f1; }
        button.active { background: #27ae60 !important; color: white; border-color: #2ecc71; }
        button.fault-active { background: #c0392b !important; color: white; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        select { width: 100%; padding: 6px; font-size: 12px; margin-bottom: 10px; border-radius: 4px; }
    </style>
</head>
<body>

<div id="ctrl-panel">
    <div class="panel-title">ğŸš¢ æŸ´æ²¹æœºå†·å´ç³»ç»Ÿä»¿çœŸæ§åˆ¶å°</div>
    <div class="btn-group">
        <button onclick="autoWire()">è‡ªåŠ¨æ¥çº¿</button>
        <button onclick="autoPipe()">è‡ªåŠ¨è¿ç®¡</button>
        <button id="p-btn" onclick="togglePump()">å¯åŠ¨æ·¡æ°´æ³µ</button>
        <button id="e-btn" onclick="toggleEngine()">å¯åŠ¨æŸ´æ²¹æœº</button>
    </div>
    <select id="load-sel" onchange="updateLoad()">
        <option value="0.3">ä¸»æœºä½è´Ÿè· (30% Load)</option>
        <option value="0.6">ä¸»æœºé«˜è´Ÿè· (80% Load)</option>
    </select>
    <div class="btn-group">
        <button id="f1" onclick="setFault(1)">æ•…éšœ1</button>
        <button id="f2" onclick="setFault(2)">æ•…éšœ2</button>
        <button id="f3" onclick="setFault(3)">æ•…éšœ3</button>
        <button id="f4" onclick="setFault(4)">æ•…éšœ4</button>
        <button id="f5" onclick="setFault(5)">æ•…éšœ5</button>
        <button id="f6" onclick="setFault(6)">æ•…éšœ6</button>
    </div>
    <button style="width:100%; background:#7f8c8d; color:white; margin-top:5px;" onclick="resetFault()">å¤ä½æŠ¥è­¦</button>
    <button style="width:100%; background:#e67e22; color:white; margin-top:5px;" onclick="resetSystem()">é‡ç½®ç³»ç»Ÿ</button>
</div>

<canvas id="sim"></canvas>

<script>
/** --- é…ç½®ä¸çŠ¶æ€ --- **/
const cvs = document.getElementById('sim');
const ctx = cvs.getContext('2d');
cvs.width = window.innerWidth;
cvs.height = window.innerHeight;

let sys = {
    realT: 20, mass: 35.0, pumpOn: false, engOn: false, load: 0.3, fault: 0,
    pipes: [], wires: [], trend: [], timer: 0, lastValvePos: 0,
    flowOffset: 0 // ç”¨äºæµåŠ¨åŠ¨ç”»çš„åç§»
};

let pid = {
    pvDisp: "---", sv: 80.0, out: 4.0, mode: 'auto',
    kp: 2.5, ki: 0.04, kd: 0.08, integral: 0, lastErr: 0, manOut: 4.0
};

let trans = { zero: 0.5, span: 0.5 };

class Component {
    constructor(id, x, y, w, h, name, type) {
        Object.assign(this, {id, x, y, w, h, name, type, ports: []});
    }
    addP(dx, dy, type, id) { this.ports.push({dx, dy, type, id}); }
}

const comps = {
    eng: new Component('eng', 420, 260, 280, 180, 'èˆ¹èˆ¶æŸ´æ²¹æœº', 'eng'),
    pump: new Component('pump', 60, 350, 100, 120, 'é«˜æ¸©æ·¡æ°´æ³µ', 'pump'),
    tç®¡: new Component('tç®¡', 80, 540, 60, 60, 'Tå‹ç®¡æ¥å¤´', 't'),
    cool: new Component('cool', 320, 680, 220, 100, 'æ·¡æ°´å†·å´å™¨', 'cool'),
    valve: new Component('valve', 650, 520, 140, 100, 'ç”µåŠ¨è°ƒèŠ‚é˜€', 'valve'),
    pt: new Component('pt', 300, 270, 80, 40, 'PT100æ„Ÿæ¸©å…ƒä»¶', 'pt'),
    trans: new Component('trans', 270, 20, 140, 140, 'æ¸©åº¦å˜é€å™¨', 'trans'),
    pid: new Component('pid', 950, 30, 240, 440, 'æ™ºèƒ½PIDè°ƒèŠ‚å™¨', 'pid'),
    mon: new Component('mon', 860, 500, 420, 250, 'è¿œç¨‹ç›‘æ§ç«™', 'mon') // å®½åº¦å˜ä¸º1.5å€
};

// æ¥å£ç»‘å®šé€»è¾‘
comps.eng.addP(30, 0, 0, 'out'); comps.eng.addP(250, 170, 0, 'in');
comps.pump.addP(50, 0, 0, 'in'); comps.pump.addP(50, 120, 0, 'out');
comps.tç®¡.addP(30, 0, 0, 'in'); comps.tç®¡.addP(60, 30, 0, 'r'); comps.tç®¡.addP(30, 60, 0, 'b');
comps.cool.addP(20, 0, 0, 'in'); comps.cool.addP(180, 0, 0, 'out');
comps.valve.addP(0, 50, 0, 'lin'); comps.valve.addP(50, 100, 0, 'bin'); comps.valve.addP(50, 0, 0, 'tout');
comps.valve.addP(130, 40, 1, 'w1'); comps.valve.addP(130, 80, 1, 'w2');
comps.pt.addP(0, 20, 1, 'l'); comps.pt.addP(80, 20, 1, 'r');
comps.trans.addP(40, 140, 1, 'b1'); comps.trans.addP(70, 140, 1, 'b2'); comps.trans.addP(100, 140, 1, 'b3');
comps.trans.addP(140, 40, 1, 'o1'); comps.trans.addP(140, 80, 1, 'o2');
comps.pid.addP(0, 50, 1, 'i1'); comps.pid.addP(0, 90, 1, 'i2');
comps.pid.addP(0, 260, 1, 'o1'); comps.pid.addP(0, 300, 1, 'o2');
comps.pid.addP(120, 440, 1, 'm1'); comps.pid.addP(160, 440, 1, 'm2');
comps.mon.addP(210, 0, 1, 'mi1'); comps.mon.addP(250, 0, 1, 'mi2');

/** --- ç‰©ç†é€»è¾‘ --- **/
function getResValue() {
    if (sys.fault === 1) return 9999;
    if (sys.fault === 2) return 0.01;
    return 100 + sys.realT * 0.3851;
}

function getTransmA() {
    if (sys.fault === 4 || sys.wires.length < 5) return 0;
    if (sys.fault === 1) return 21.6;
    if (sys.fault === 2) return 3.6;
    let r = getResValue();
    let mA = ((r - 100) / 38.51) * 16 + 4;
    mA = (mA + (trans.zero - 0.5) * 4) * (1 + (trans.span - 0.5) * 0.2);
    if (sys.fault === 3) mA *= 1.05;
    return Math.max(0, Math.min(24, mA));
}

function updatePhysics() {
    if (sys.engOn) {
        let vPos = sys.fault === 6 ? sys.lastValvePos : Math.max(0, Math.min(1, (pid.out - 4) / 16));
        sys.lastValvePos = vPos;
        let heatGain = sys.load * 0.22; // ç¨å¾®åŠ å¿«
        let coolLoss = sys.pumpOn ? (vPos * 0.16 + 0.01) : 0.002;
        sys.realT += (heatGain - coolLoss) / (sys.mass / 20); 
    } else {
        sys.realT -= (sys.realT - 20) * 0.01;
    }
    sys.realT = Math.max(20, Math.min(105, sys.realT));

    let mA = getTransmA();
    pid.pvDisp = (mA < 3.8) ? "LLLL" : (mA > 21.0 ? "HHHH" : ((mA - 4) / 16 * 100).toFixed(1));

    if (pid.mode === 'auto') {
        let pvNum = parseFloat(pid.pvDisp) || (pid.pvDisp === "HHHH" ? 100 : 0);
        let err = pvNum - pid.sv;
        pid.integral += err * 0.012;
        pid.integral = Math.max(-10, Math.min(10, pid.integral));
        let out = 4 + (pid.kp * err) + (pid.ki * pid.integral * 10) + (pid.kd * (err - pid.lastErr) * 20);
        pid.out = Math.max(4, Math.min(20, out));
        pid.lastErr = err;
    } else {
        pid.out = pid.manOut;
    }
    if (sys.fault === 5) pid.out = 0;

    if (sys.timer++ % 20 === 0) {
        let val = parseFloat(pid.pvDisp) || (pid.pvDisp === "HHHH" ? 100 : 20);
        sys.trend.push({pv: val, sv: pid.sv, vo: sys.lastValvePos});
        if (sys.trend.length > 120) sys.trend.shift();
    }
    if (sys.pumpOn) sys.flowOffset -= 2; // æµåŠ¨åŠ¨ç”»åç§»
}

/** --- ç»˜åˆ¶é€»è¾‘ --- **/
function render() {
    ctx.clearRect(0, 0, cvs.width, cvs.height);
    
    // ç»˜åˆ¶ç®¡è·¯åŠæµåŠ¨æ•ˆæœ
    sys.pipes.forEach(p => drawLink(p, '#95a5a6', 16, true, true));
    sys.wires.forEach(w => drawLink(w, '#d35400', 2, false, false));

    Object.values(comps).forEach(c => {
        ctx.save(); ctx.translate(c.x, c.y);
        drawComp(c);
        ctx.fillStyle = "#2c3e50"; ctx.font = "bold 13px Sans-Serif"; ctx.textAlign = "center";
        ctx.fillText(c.name, c.w/2, c.h + 22);
        c.ports.forEach(p => {
            ctx.fillStyle = "#ecf0f1"; ctx.strokeStyle = "#34495e";
            if(p.type === 0) ctx.fillRect(p.dx-8, p.dy-8, 16, 16);
            else { ctx.beginPath(); ctx.arc(p.dx, p.dy, 6, 0, 7); ctx.fill(); ctx.stroke(); }
        });
        ctx.restore();
    });
    updatePhysics();
    requestAnimationFrame(render);
}

function drawComp(c) {
    let g = ctx.createLinearGradient(0, 0, 0, c.h);
    if (c.type === 'eng') {
        g.addColorStop(0, "#7f8c8d"); g.addColorStop(1, "#34495e");
        ctx.fillStyle = g; ctx.roundRect(10, 30, 260, 140, 5); ctx.fill();
        for(let i=0; i<6; i++) {
            let offset = sys.engOn ? Math.sin(sys.timer/3 + i) * 12 : 0;
            ctx.fillStyle = "#2c3e50"; ctx.fillRect(45+i*35, 10 + offset, 24, 30);
            if(sys.engOn && Math.sin(sys.timer/3 + i) > 0.8) { // ç‡ƒçˆ†ç«èŠ±
                ctx.fillStyle = "#e67e22"; ctx.beginPath(); ctx.arc(57+i*35, 15+offset, 5, 0, 7); ctx.fill();
            }
        }
        ctx.fillStyle = "#000"; ctx.fillRect(40, -35, 80, 25);
        ctx.fillStyle = "#0f0"; ctx.font = "14px monospace"; ctx.fillText(sys.realT.toFixed(1)+"Â°C", 45, -18);
    } else if (c.type === 'pt') {
        ctx.strokeStyle = "#2c3e50"; ctx.beginPath(); ctx.moveTo(0, 20); 
        for(let i=0;i<4;i++){ctx.lineTo(20+i*10,10);ctx.lineTo(25+i*10,30);} ctx.lineTo(80, 20); ctx.stroke();
        ctx.fillStyle = "#000"; ctx.fillRect(-10, -30, 100, 22);
        ctx.fillStyle = "#0f0"; ctx.font = "12px monospace";
        ctx.fillText(sys.fault===1 ? "âˆ Î©" : getResValue().toFixed(2) + " Î©", -5, -15);
    } else if (c.type === 'trans') {
        g.addColorStop(0, "#f1c40f"); g.addColorStop(1, "#f39c12");
        ctx.fillStyle = g; ctx.fillRect(0,0,140,140); ctx.strokeRect(0,0,140,140);
        ctx.fillStyle = "#2c3e50"; ctx.fillRect(20,40,100,8); ctx.fillRect(20,90,100,8);
        ctx.fillStyle = "#e67e22"; ctx.fillRect(20+trans.zero*90,35,10,18); ctx.fillRect(20+trans.span*90,85,10,18);
        ctx.fillStyle = "#000"; ctx.fillRect(-65, 55, 60, 25);
        ctx.fillStyle = "#0f0"; ctx.font = "12px monospace";
        ctx.fillText(getTransmA().toFixed(2)+"mA", -62, 72);
    } else if (c.type === 'pid') {
        ctx.fillStyle = "#2c3e50"; ctx.roundRect(0, 0, 240, 440, 8); ctx.fill();
        ctx.fillStyle = "#000"; ctx.fillRect(12, 10, 216, 130);
        ctx.fillStyle = "#0f0"; ctx.font = "14px Courier New";
        ctx.fillText("PV: " + pid.pvDisp + " â„ƒ", 25, 45);
        ctx.fillText("SV: " + pid.sv.toFixed(1) + " â„ƒ", 25, 80);
        ctx.fillText("OUT: " + pid.out.toFixed(2) + " mA", 25, 115);
        // æŒ‡ç¤ºç¯
        const drawLED = (x, y, label, on, color) => {
            ctx.fillStyle = on ? color : "#1a1a1a"; ctx.beginPath(); ctx.arc(x, y, 7, 0, 7); ctx.fill();
            ctx.fillStyle = "#fff"; ctx.font = "10px Arial"; ctx.fillText(label, x + 15, y + 4);
        };
        drawLED(25, 160, "RUN", sys.engOn, "#2ecc71");
        drawLED(90, 160, "MAN", pid.mode === 'manual', "#f1c40f");
        drawLED(155, 160, "AUTO", pid.mode === 'auto', "#2ecc71");
        drawLED(25, 190, "FAULT", sys.fault > 0, "#e74c3c");
        ctx.fillStyle="#34495e"; ctx.fillRect(100,180,110,25); ctx.fillStyle="#fff"; ctx.fillText("MAN/AUTO", 125, 196);
        // PID å‚æ•°
        ctx.fillStyle = "#1a1a1a"; ctx.fillRect(12, 220, 216, 90);
        ctx.fillStyle = "#0f0"; ctx.font = "12px monospace";
        const drawParam = (y, label, val) => {
            ctx.fillText(label + ": " + val.toFixed(2), 25, y);
            ctx.fillStyle = "#444"; ctx.fillRect(150, y-12, 25, 16); ctx.fillRect(185, y-12, 25, 16);
            ctx.fillStyle = "#fff"; ctx.fillText("-", 159, y); ctx.fillText("+", 194, y);
            ctx.fillStyle = "#0f0";
        };
        drawParam(245, "Kp", pid.kp); drawParam(275, "Ki", pid.ki); drawParam(305, "Kd", pid.kd);
        ctx.fillStyle="#fff"; ctx.font="11px Arial"; ctx.fillText("MAN OUT:", 20, 350);
        ctx.fillStyle="#555"; ctx.fillRect(20,360,200,8);
        ctx.fillStyle="#e67e22"; ctx.fillRect(20+((pid.manOut-4)/16)*190,353,10,22);
        ctx.fillStyle="#fff"; ctx.fillText("SV SET:", 20, 395);
        ctx.fillStyle="#555"; ctx.fillRect(20,405,200,8);
        ctx.fillStyle="#3498db"; ctx.fillRect(20+((pid.sv-20)/80)*190,398,10,22);
    } else if (c.type === 'mon') {
        ctx.fillStyle = "#1a1a1a"; ctx.roundRect(0,0,420,250,5); ctx.fill(); // å®½åº¦1.5å€
        if(sys.trend.length > 2){
            ctx.strokeStyle="#555"; ctx.beginPath(); // ç½‘æ ¼
            for(let i=1;i<5;i++){ ctx.moveTo(0,170-i*37); ctx.lineTo(420,170-i*37); } ctx.stroke();
            ctx.strokeStyle="red"; ctx.setLineDash([4,4]); ctx.beginPath();
            let sy=170-(pid.sv-20)*1.5; ctx.moveTo(10,sy); ctx.lineTo(410,sy); ctx.stroke();
            ctx.setLineDash([]); ctx.strokeStyle="#0f0"; ctx.lineWidth=2; ctx.beginPath();
            sys.trend.forEach((d,i)=>{let x=10+i*3.4, y=170-(d.pv-20)*1.5; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);}); ctx.stroke();
            ctx.strokeStyle="#3498db"; ctx.beginPath();
            sys.trend.forEach((d,i)=>{let x=10+i*3.4, y=170-d.vo*150; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);}); ctx.stroke();
        }
        ctx.fillStyle = "#fff"; ctx.font = "12px Arial";
        let statusText = sys.fault === 0 ? "ç³»ç»Ÿè¿è¡Œæ­£å¸¸" : "æŠ¥è­¦: " + ["","PT100æ–­è·¯","PT100çŸ­è·¯","å˜é€å™¨æ¼‚ç§»","å˜é€å™¨è¾“å‡ºå¼€è·¯","PIDæ§åˆ¶å™¨è¾“å‡ºå›è·¯æ–­è·¯","é˜€é—¨æ‰§è¡Œå™¨å¡æ­»"][sys.fault];
        ctx.fillText(statusText, 20, 210);
        ctx.fillText("PIDæ¨¡å¼: " + (pid.mode==='auto'?'è‡ªåŠ¨':'æ‰‹åŠ¨'), 20, 230);
    } else if (c.type === 'pump') {
        g.addColorStop(0, "#3498db"); g.addColorStop(1, "#2980b9");
        ctx.fillStyle = sys.pumpOn ? g : "#bdc3c7";
        ctx.beginPath(); ctx.ellipse(50, 60, 45, 55, 0, 0, 7); ctx.fill(); ctx.stroke();
        if(sys.pumpOn){
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.beginPath();
            ctx.moveTo(50, 60); ctx.lineTo(50+Math.cos(sys.timer/3)*35, 60+Math.sin(sys.timer/3)*35); ctx.stroke();
        }
    } else if (c.type === 'valve'){
        ctx.lineWidth = 14; ctx.strokeStyle = "#7f8c8d";
        ctx.beginPath(); ctx.moveTo(0,50); ctx.lineTo(50,50); ctx.lineTo(50,0); ctx.moveTo(50,50); ctx.lineTo(50,100); ctx.stroke();
        ctx.fillStyle = "#2c3e50"; ctx.fillRect(75, 20, 55, 75);
        ctx.fillStyle = "#000"; ctx.fillRect(135, 45, 60, 25);
        ctx.fillStyle = "#f1c40f"; ctx.font = "13px monospace"; ctx.fillText((sys.lastValvePos*100).toFixed(0)+"%", 140, 62);
    } else if (c.type === 'cool'){
        ctx.fillStyle = "#ecf0f1"; ctx.roundRect(0,0,220,100,10); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = "#3498db"; ctx.lineWidth=2; ctx.strokeRect(10,10,200,80);
    }
}

/** --- è¿çº¿ä¸æµåŠ¨åŠ¨ç”» --- **/
function drawLink(l, c, w, isPipe, animate) {
    let a = gAbs(l.fc, l.fp), b = gAbs(l.tc, l.tp);
    ctx.strokeStyle = c; ctx.lineWidth = w; ctx.lineJoin = "round"; ctx.lineCap = "round";
    ctx.beginPath();
    if(isPipe) {
        ctx.moveTo(a.x, a.y); ctx.lineTo(a.x, b.y); ctx.lineTo(b.x, b.y);
    } else {
        ctx.moveTo(a.x, a.y); ctx.bezierCurveTo(a.x, a.y+70, b.x, b.y-70, b.x, b.y);
    }
    ctx.stroke();

    // ç»˜åˆ¶æ°´æµæµåŠ¨æ•ˆæœ
    if(animate && sys.pumpOn) {
        ctx.save();
        ctx.strokeStyle = "#3498db"; ctx.lineWidth = 4;
        ctx.setLineDash([8, 12]);
        ctx.lineDashOffset = sys.flowOffset;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y); ctx.lineTo(a.x, b.y); ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.restore();
    }
}

/** --- äº¤äº’é€»è¾‘ --- **/
let dragComp = null, dX = 0, dY = 0, isDraggingPanel = false, pX, pY;

function handleInteraction(c, mx, my, isMove) {
    if(c.type === 'pid') {
        if(!isMove && mx > 100 && mx < 210 && my > 180 && my < 205) { pid.mode = (pid.mode==='auto'?'manual':'auto'); return true; }
        if(!isMove && mx > 150 && mx < 210 && my > 220 && my < 320) {
            if(my < 260) pid.kp += (mx > 180 ? 0.1 : -0.1);
            else if(my < 290) pid.ki += (mx > 180 ? 0.01 : -0.01);
            else pid.kd += (mx > 180 ? 0.01 : -0.01);
            pid.kp = Math.max(0, pid.kp); pid.ki = Math.max(0, pid.ki); pid.kd = Math.max(0, pid.kd);
            return true;
        }
        if(my > 340 && my < 375) { pid.manOut = 4 + (Math.max(0, Math.min(1, (mx-20)/190)) * 16); return true; }
        if(my > 385 && my < 420) { pid.sv = 20 + (Math.max(0, Math.min(1, (mx-20)/190)) * 80); return true; }
    }
    if(c.type === 'trans') {
        if(my > 30 && my < 60) { trans.zero = Math.max(0, Math.min(1, (mx-20)/90)); return true; }
        if(my > 80 && my < 110) { trans.span = Math.max(0, Math.min(1, (mx-20)/90)); return true; }
    }
    return false;
}

window.onmousedown = (e) => {
    const cp = document.getElementById('ctrl-panel');
    if(e.clientX > cp.offsetLeft && e.clientX < cp.offsetLeft+cp.offsetWidth && e.clientY > cp.offsetTop && e.clientY < cp.offsetTop+cp.offsetHeight) {
        if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'SELECT') { isDraggingPanel = true; pX = e.clientX-cp.offsetLeft; pY = e.clientY-cp.offsetTop; }
        return;
    }
    for(let c of Object.values(comps)) {
        if(e.clientX > c.x && e.clientX < c.x+c.w && e.clientY > c.y && e.clientY < c.y+c.h) {
            let mx = e.clientX - c.x, my = e.clientY - c.y;
            if(handleInteraction(c, mx, my, false)) return;
            dragComp = c; dX = e.clientX-c.x; dY = e.clientY-c.y; return;
        }
    }
};

window.onmousemove = (e) => {
    if(isDraggingPanel) {
        const cp = document.getElementById('ctrl-panel');
        cp.style.left = (e.clientX-pX)+"px"; cp.style.top = (e.clientY-pY)+"px";
    }
    if(dragComp) { dragComp.x = e.clientX-dX; dragComp.y = e.clientY-dY; }
    if(!dragComp && !isDraggingPanel && e.buttons === 1) {
        for(let c of Object.values(comps)) {
            if(e.clientX > c.x && e.clientX < c.x+c.w && e.clientY > c.y && e.clientY < c.y+c.h) handleInteraction(c, e.clientX-c.x, e.clientY-c.y, true);
        }
    }
};

window.onmouseup = () => { dragComp = null; isDraggingPanel = false; };

function gAbs(cid, pid) { let c = comps[cid], p = c.ports.find(x => x.id === pid); return { x: c.x + p.dx, y: c.y + p.dy }; }
function autoWire() {
    sys.wires = [
        {fc:'pt',fp:'l',tc:'trans',tp:'b1'}, {fc:'pt',fp:'r',tc:'trans',tp:'b2'}, {fc:'pt',fp:'r',tc:'trans',tp:'b3'},
        {fc:'trans',fp:'o1',tc:'pid',tp:'i1'}, {fc:'trans',fp:'o2',tc:'pid',tp:'i2'},
        {fc:'pid',fp:'o1',tc:'valve',tp:'w1'}, {fc:'pid',fp:'o2',tc:'valve',tp:'w2'},
        {fc:'pid',fp:'m1',tc:'mon',tp:'mi1'}, {fc:'pid',fp:'m2',tc:'mon',tp:'mi2'}
    ];
}
function autoPipe() {
    sys.pipes = [
        {fc:'eng',fp:'out',tc:'pump',tp:'in'}, {fc:'pump',fp:'out',tc:'tç®¡',tp:'in'},
        {fc:'tç®¡',fp:'r',tc:'valve',tp:'lin'}, {fc:'tç®¡',fp:'b',tc:'cool',tp:'in'},
        {fc:'cool',fp:'out',tc:'valve',tp:'bin'}, {fc:'valve',fp:'tout',tc:'eng',tp:'in'}
    ];
}
function togglePump() { sys.pumpOn = !sys.pumpOn; document.getElementById('p-btn').classList.toggle('active', sys.pumpOn); }
function toggleEngine() { if(!sys.pumpOn){alert("å†·å´æ°´æœªå»ºç«‹å¾ªç¯ï¼Œä¸¥ç¦å¯åŠ¨æŸ´æ²¹æœºï¼"); return;} sys.engOn = !sys.engOn; document.getElementById('e-btn').classList.toggle('active', sys.engOn); }
function updateLoad() { sys.load = parseFloat(document.getElementById('load-sel').value); }
function setFault(n) { resetFault(); sys.fault = n; document.getElementById('f'+n).classList.add('fault-active'); }
function resetFault() { sys.fault = 0; for(let i=1; i<=6; i++) document.getElementById('f'+i).classList.remove('fault-active'); }
function resetSystem() { location.reload(); }

render();
</script>
</body>

</html>
